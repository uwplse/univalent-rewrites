\section{Related Work}

% TODO check survey paper for more stuff/better stuff
% TODO also remove any content that is too similar with survey paper

We discuss related work in proof repair, proof refactoring, proof reuse, and proof design.
More can be found in a recent survey of proof engineering~\cite{PGL-045}.

\paragraph{Proof Repair}

\toolname is not the first tool to automatically repair broken proofs.
\textsc{Pumpkin Patch}~\cite{pumpkinpatch} is a tool for repairing broken proofs in Coq.
The search procedures in \textbf{Configure} are based partly on ideas from \textsc{Pumpkin Patch}, which includes
similar search procedures for discovering patches to fix broken proofs.
Unlike \toolname, however, \textsc{Pumpkin Patch} does not apply the patches that it finds,
nor does it handle changes in structure or include any support for tactics beyond the use of hint databases.
\toolname addresses all three of these limitations.

Proof repair can be viewed as a form of \textit{program repair}~\cite{Monperrus:2018:ASR:3177787.3105906, Gazzola:2018:ASR:3180155.3182526}
specific to the domain of proof assistants.
Proof assistants like Coq are a good fit for program repair: A recent paper~\cite{Qi:2015:APP:2771783.2771791} 
recommends that program repair tools draw on extra information
such as specifications or example patches. In Coq, specifications and examples 
are rich and widely available: specifications thanks to dependent types,
and examples thanks to constructivism.

\paragraph{Proof Refactoring}

Proof repair is closely related to proof refactoring~\cite{WhitesidePhD}, and a number of the changes
that \toolname supports like changing constructor names can be viewed as refactorings.
The proof refactoring tool Levity~\cite{Bourke12} has, like \toolname, seen industrial use.
Unlike \toolname, it focuses on a specific refactoring task, whereas \toolname is configurable to many different kinds of changes.
Chick~\cite{robert2018} and RefactorAgda~\cite{wibergh2019} are proof refactoring tools that
also support a few changes that can be viewed as repairs~\cite{PGL-045}.
%Chick operates over a Gallina-like language, while RefactorAgda is implemented in Agda.
Unlike \toolname, the changes these tools support are still primarily syntactic,
and neither of these tools have tactic support.

A few proof refactoring tools operate directly over tactics.
POLAR~\cite{Dietrich2013} refactors proof scripts in languages based on Isabelle/Isar~\cite{Wenzel2007isar}.
CoqPIE~\cite{Roe2016} is an IDE with support for simple refactorings of Ltac scripts like renaming hypotheses.
Tactician~\cite{adams2015} is a proof script refactoring tool that focuses on switching between tactics and tacticals,
for example by adding semicolons to group tactics.
This approach is not tractable for handling more complex changes;
\citet{robert2018} discusses the challenges in detail.

\paragraph{Proof Reuse}

Proof repair is a form of proof reuse with the additional constraint that one specification ceases to exist.
A few proof reuse tools work by proof term transformation and so can handle this additional constraint.
The namesake of this paper is based on the name of a paper describing proof reuse tool~\cite{Johnsen2004}
that generalizes theorems in Isabelle/HOL.
\toolname's proof term transformation generalizes the proof term transformation from \textsc{Devoid}~\cite{Ringer2019},
which transforms proofs along the specific class of changes called algebraic ornaments~\cite{mcbride}.
\citet{magaud2000changing} implements a proof term transformation for translating proof terms between
unary and binary natural numbers. 
The latter two of these tools fit into configurations for \toolname,
and none implements tactic support in Coq like \toolname does.
The expansion algorithm from \citet{magaud2000changing} may further help improve \toolname
by automating some of the manual steps in manual configuration.

The \toolname proof term transformation implements transport across equivalences.
Transport is realizable as a function in univalent type theories~\cite{univalent2013homotopy}.
The univalent parametricity framework~\cite{tabareau2017equivalences} realizes univalent transport for certain types
in a non-univalent type theory, only sometimes relying on additional axioms beyond the core type theory of Coq.
While powerful, neither of these approaches to transport remove references to the old type, making them poorly suited for repair.

Recent work~\cite{tabareau2019marriage} extends the univalent parametricity framework with 
a white-box proof term transformation using hints proven by the proof engineer.
This approach may be well suited for proof repair.
However, it relies on proof obligations from the proof engineer that establish what is effectively the correctness criteria
for the configuration in \toolname, while \toolname needs only that it holds metatheoretically.
In addition, it does not include search procedures like \toolname to discover new equivalences from types,
and it does not include tactic script generation like \toolname.
Finally, it does not implement any support for porting definitional equalities to propositional equalities,
instead relying on the original black-box functionality of the univalent parametricity framework to handle those cases;
the \lstinline{Iota} rule addresses this problem in \toolname and is based on lessons learned from reading that article.
The most fruitful progress may come from integrating these tools together to take advantage of the benefits that both offer.

The univalent parametricity framework implements type-directed search, a feature that \toolname does not yet support.
The framework achieve this using type classes~\cite{Sozeau2008}; this does not always scale well~\cite{tabareau2019marriage}.
Both \toolname and the univalent parametricity framework could benefit from implement type-directed search using e-graphs~\cite{egraph1}.
Of particular interest are the univalent e-graphs developed for congruence closure in Cubical Agda~\cite{egraph6},
which prove the crucial thereom necessary to use e-graphs not derivable in other dependent type theories~\cite{egraph7},
and which should allow for efficient and elegant automatic transport across equivalences.

\paragraph{Proof Design}

Much of the work on proof engineering focuses on designing proofs
in a way that is resilient to change, rather than fixing proofs that are already broken.
This can take the form of design principles, for example using 
information hiding techniques~\cite{Woos:2016:PCF:2854065.2854081, Klein:2014:CFV:2584468.2560537}
or any of the various structures~\cite{Chrzaszcz2003, Sozeau2008, Saibi:PhD} for encoding interfaces in Coq,
thereby localizing the burden of change to the interface.
Design and repair are complementary: design requires foresight, whereas repair can be applied retroactively.
Proof repair can help with changes that occur outside of the proof engineer's control,
or with changes that are difficult to protect against even with informed design.

Another approach to this is to use heavy proof automation, for example through
program-specific proof automation~\cite{Chlipala:2013:CPD:2584504},
implementations of decision procedures~\cite{Pugh1991},
and hammers~\cite{Blanchette2016b, Blanchette2013, Kaliszyk2014, Czajka2018}.
The benefit of an automation-heavy style is that this localizes the burden of change to the automation itself.
On the other hand, heavy automation can produce terms that are large and slow to type check,
and tactics can be difficult to debug when they fail.
The degree to which proof engineers rely on automation varies, as seen in the data from the
\textsc{REPLica} user study of Coq proof engineers~\cite{replica}.
While these approaches are also complementary, more work will be needed for \toolname to better support 
proof developments in this style.



