\section{Example Configurations}
\label{sec:search}

combining the case study and configuration ones: guide by case studies, then explain configuration

This is basically the ``common interface'' the journal paper of Univalent Parametricity mentions, except they say it
doesn't scale to automation. In fact it can if you automate entire classes of relations between types rather than
force the user to do it on an ad-hoc basis or try to write a tool that solves the general case. So that is what
we are doing here.

\subsection{Industrial Use}

\subsection{Free Dependent Types}

\subsection{Unary and Binary Numbers}

\subsection{REPLICA Benchmarks}

Next, for the four classes of equivalences we support (maybe more if we have time), we define the constructor, eliminator, and identity rules.
We prove that each of these satisfies the correctness criteria.
Our implementation also (or alternatively, depending on how much time we have) generates these proofs on an ad-hoc basis because
the general proof isn't possible within Coq.

TODO bin to nat


\subsection{Four Transformations}

% TODO oracles, naming, consider just doing code and generating proofs in Coq

Here are the constructor, eliminator, and identity rules for our four implemented transformations (very informal WIP).
The equivalence between $A$ and $B$ can be constructed in terms of these.
This shows just one direction---the opposite is similar.

\subsubsection{Swap}

Let $A$ and $B$ be inductive types:

\begin{lstlisting}
$A$ := $\mathrm{Ind} (\mathit{Ty}_A : \Pi (\vec{i_A} : \vec{\mathrm{X}_A}) . \mathrm{s}_A)\{\mathrm{C}_{A_1}, \ldots, \mathrm{C}_{A_n}\}$
$B$ := $\mathrm{Ind} (\mathit{Ty}_B : \Pi (\vec{i_B} : \vec{\mathrm{X}_B}) . \mathrm{s}_B)\{\mathrm{C}_{B_1}, \ldots, \mathrm{C}_{B_n}\}$
\end{lstlisting}		
Assume there is some invertible swap map $m$ such that for any index $j$,
\lstinline{C}$_{B_{m(j)}}$ is exactly \lstinline{C}$_{A_j}[B / A]$.
Then:

\begin{lstlisting}
DepConstr(j, A) : C$_{A_{j}}$ := Constr(j, A) 
DepConstr(j, B) : C$_{A_{j}}$[B / A] := Constr(m(j), B)

DepElim(a, p){f$_{1}$, $\ldots$, f$_{n}$} : p a := Elim(a, p){f$_{1}$, $\ldots$, f$_{n}$}
DepElim(b, p){f$_{1}$, $\ldots$, f$_{n}$} : p b := Elim(b, p){f$_{m(1)}$, $\ldots$, f$_{m(n)}$}

IdEta(A) := $\lambda$ ($\vec{t}$ : $\vec{T}$) (a : A $\vec{t}$).a
IdEta(B) := $\lambda$ ($\vec{t}$ : $\vec{T}$) (b : B $\vec{t}$).b
\end{lstlisting}

\subsubsection{Algebraic}

It is straightforward to fit the search algorithm from DEVOID into this framework, and in fact
we can loosen the restriction that the language has primitive projections.
Let $A$ be $A$ from DEVOID, let $B_{ind}$ be $B$ from DEVOID, let $I_B$ be $I_B$ from DEVOID,
and let \lstinline{index} be \lstinline{index} from DEVOID.
Let $B$ wrap $B_{ind}$ packed into a sigma type:

\begin{lstlisting}
B := $\lambda$ ($\vec{t}$ : $\vec{T}$) . ($\Sigma$ (i : I$_B$ $\vec{t}$) . B$_{ind}$ (index i $\vec{t}$))
\end{lstlisting}
Let $\vec{T_{B_j}}$ be the arguments of constructor type $C_{B_j}$ (type of constructor of $B_{\mathrm{ind}}$).
Define \lstinline{DepConstr(j, B)} recursively using the following derivation (based on and same fall-through convention as the DEVOID paper for now,
and I'd prefer to move this away from a derivation but not sure how to do so and maintain formality): % TODO check

\begin{mathpar}
\mprset{flushleft}
\small
\hfill\fbox{$\Gamma$ $\vdash$ $(T_A, T_B)$ $\Downarrow_{C}$ $t$}\\

\inferrule[Dep-Constr-Conclusion]
  { \Gamma \vdash \vec{t_{B_j}} : \vec{T_{B_j}} \\ \Gamma \vdash Constr(j, B)\ \vec{t_{B_j}} : B_{\mathrm{ind}} \vec{i_B}  }
  { \Gamma \vdash (A\ \vec{i_A},\ B_{\mathrm{ind}}\ \vec{i_B}) \Downarrow_{p_{c}} \exists\ (\vec{i_B}[\mathrm{off}\ A\ B]) (Constr(j, B)\ \vec{t_{B_j}}) }

\inferrule[Dep-Constr-Index] % new hypothesis for index
  { \mathrm{new}\ n_B\ b_B \\ \Gamma,\ n_B : t_B \vdash (\Pi (n_A : t_A) . b_A,\ b_B) \Downarrow_{i_{c}} t }
  {  \Gamma \vdash (\Pi (n_A : t_A) . b_A,\ \Pi (n_B : t_B) . b_B) \Downarrow_{C} t}

\inferrule[Dep-Constr-IH] % inductive hypothesis
  { \Gamma,\ n_B : B\ \vec{i_B} \vdash (b_A [n_B / n_A], b_B [\pi_l\ n_B / \vec{i_B}[\mathrm{off}\ A\ B]]) \Downarrow_{C} t }
  { \Gamma \vdash (\Pi (n_A : A\ \vec{i_A}) . b_A, \Pi (n_B : B\ \vec{i_B}) \Downarrow_{C} \lambda (n_B : B\ \vec{i_B}) . t }

\inferrule[Dep-Constr-Prod] % otherwise, unchanged (when we get rid of the gross fall-through thing, needs not new, and needs to check t_A and t_B not IHs)
  { \Gamma,\ n_B : t_B \vdash (b_A [n_B / n_A], b_B) \Downarrow_{C} t }
  { \Gamma \vdash (\Pi (n_A : t_A) . b_A, \Pi (n_B, t_B) . b_B) \Downarrow_{C} \lambda (n_B : t_B) . t }\\

\inferrule[Dep-Constr]
{ \Gamma \vdash Constr(j, A) : C_{A_j} \\ \Gamma \vdash (C_{A_j}, C_{B_j}) \Downarrow_{C} t }
{ \Gamma \vdash (Constr(j, A), Constr(j, B_{\mathrm{ind}}) \Downarrow_{C} t }
\end{mathpar}
and \lstinline{DepElim(b, p)} similarly:

\begin{mathpar}
TODO
\end{mathpar}

Then:

\begin{lstlisting}
DepConstr(j, A) : C$_{A_{j}}$ := Constr(j, A)
DepConstr(j, B) : C$_{A_{j}}$[B / A] := DepConstr(j, B)

DepElim(a, p){f$_{1}$, $\ldots$, f$_{n}$} : p a := Elim(a, p){f$_{1}$, $\ldots$, f$_{n}$}
DepElim(b, p){f$_{1}$, $\ldots$, f$_{n}$} : p b := DepElim(b, p)

IdEta(A) := $\lambda$(a : A).a
IdEta(B) := $\lambda$(b : B).$\exists$ ($\pi_l$ b) ($\pi_r$ b)
\end{lstlisting}

% TODO investigate below projection thing, and write in when you finish
%For now assume we have some \lstinline{pack} function to pack into an existential;
%this is just for convenience.
%The indexer is just the first projection of this lifted across the eliminator rule, AFAIK---note this isn't exactly $\Pi_{l}$ like we use
%in the tool, but is really an eliminated $\Pi_{l}$? I will need to check on this, it's the only weird part.
%Also assume some \lstinline{index_args} function to add the new index to the appropriate arguments---I'll
%elaborate on this later but it's also something search needs to find and it's determined in terms of the \lstinline{indexer} that search finds.
%Also now, we no longer assume primitive projections.

\subsubsection{Unpack sigma}

This one is kind of weird but it gets us user-friendly types. I'll explain later.

\begin{lstlisting}
DepConstr(j, A) := (* TODO pack into existential, deal with equality *)
DepConstr(j, B) : C$_{B_{j}}$ := Constr(j, B)

DepElim(a, p){f$_{1}$, $\ldots$, f$_{n}$} : p a := (* TODO *)
DepElim(b, p){f$_{1}$, $\ldots$, f$_{n}$} : p b := Elim(b, p){f$_{1}$, $\ldots$, f$_{n}$}

IdEta(A) := $\lambda$(a : A).$\exists$ ($\exists$ ($\pi_l$ ($\pi_l$ a)) ($\pi_r$ ($\pi_l$ a))) ($\pi_r$ a)
IdEta(B) := $\lambda$(b : B).b
\end{lstlisting}

\subsubsection{Records and tuples}

This one should be easier. We'll play a similar trick with $B$ and $B_{ind}$ like we do for algebraic,
and give things similar names.
Then:

\begin{lstlisting}
DepConstr(j, A) : C$_{A_{j}}$ := Constr(j, A)
DepConstr(j, B) : C$_{A_{j}}$[B / A] := $\lambda$ ($\vec{t_{A_j}}$ : $\vec{T_{A_j}}$) . (* TODO recursively pack into pair *)

DepElim(a, p){f$_{1}$, $\ldots$, f$_{n}$} : p a := Elim(a, p){f$_{1}$, $\ldots$, f$_{n}$}
DepElim(b, p){f$_{1}$, $\ldots$, f$_{n}$} : p b := (* TODO recursively eliminate product *)

IdEta(A) := $\lambda$(a : A).a
IdEta(B) := (* TODO recursive eta *)
\end{lstlisting}
