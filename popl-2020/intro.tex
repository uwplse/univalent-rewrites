\section{Introduction}

Program verification makes it possible to prove programs correct.
Proof engineering has made this a lot easier in the last couple of decades.
Unfortunately, maintaining proofs of programs as those programs change over
time is still a major challenge,
so much that even experts sometimes still just start from scratch.

The problem of refactoring or repairing proofs automatically has been explored in the past,
but mostly in an ad-hoc fashion, and without actually applying discovered patches.
We show a more principled approach to proof refactoring and repair. % functions are not enough!s
This approach combines a program transformation over proof terms (Section~\ref{sec:meat})
with search procedures to instantiate the program transformation to a particular change (Section~\ref{sec:search})
and a decompiler from proof terms back to tactics (Section~\ref{sec:decompiler}).

The key is to view every change from an old specification to new specification as corresponding to one or more equivalences,
possibly with additional information (equivalences between sigma types).
The program transformation then transports the proof term across the equivalence,
producing a term that no longer refers to the old specification.
Finally, the tactic decompiler takes those proof terms back to tactics that a proof engineer
can actually maintain.

We implement this in \toolname, a plugin for Coq 8.8. We use \toolname to do a lot of things:

\begin{enumerate}
  \item things
\end{enumerate}

We also contribute things:

\begin{enumerate}
\item things
\end{enumerate}
