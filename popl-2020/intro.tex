\section{Introduction}

Program verification with interactive theorem provers has come a long way since its inception,
especially when it comes to the scale of programs that we can prove correct.
The seL4~\cite{Klein2009} verified operating system kernel, for example,
is the effort of a team of proof engineers over more than twenty years and spanning more than
a million lines of proof.
Given historical critique of verification~\cite{DeMillo1977} (emphasis ours):

\begin{quote}
A \textit{sufficiently fanatical researcher}
might be willing to devote \textit{two or 
three years} to verifying a significant 
piece of software if he could be 
assured that the software would remain stable.
\end{quote}
we can conlude that, since 1977, either verification has become much easier,
or our researchers have become much more fanatical. Unfortunately, not all has changed (emphasis still ours):

\begin{quote}
But real-life programs need to 
be maintained and modified. 
There is \textit{no reason to believe} that verifying a modified program is any 
easier than verifying the original the 
first time around.
\end{quote}
Tools that can automatically refactor or repair proofs~\cite{wibergh2019, WhitesidePhD, Dietrich2013, adams2015, Bourke12, Roe2016, robert2018, pumpkinpatch}
give us reason to believe that verifying a modified program is sometimes easier than verifying the original the first time
around, even when proof engineers do not follow good development processes,
or when change occurs outside of proof engineers' control~\cite{PGL-045}.
Still, the challenges of maintaining verified programs remain so difficult that
sometimes, even experts give up in the face of change~\cite{replica}.

We make progress toward two open challenges in proof repair:

\begin{enumerate}
%\item Few tools~\cite{robert2018, wibergh2019} support both proof refactoring (semantics-preserving changes) and repair (non-semantics-preserving changes)~\cite{PGL-045}.
\item Proof repair tools support limited classes of changes like non-structural changes~\cite{pumpkinpatch} or a predefined set
of changes~\cite{robert2018, wibergh2019}, and these are not informed by real user needs~\cite{replica}.
\item Proof repair tools are not yet integrated with typical proof engineering workflows like tactics~\cite{PGL-045, pumpkinpatch, robert2018}.
\end{enumerate}
Our progress towards each these challenges leverages three key insights: % TODO dan comment

\begin{enumerate}
\item Proof repair is a form of proof reuse, with the additional
challenge that the specification about which
we are reusing proofs ceases to exist.
The key to supporting proof repair is to build a proof reuse
tool that can handle that additional challenge (Section~\ref{sec:key1}). 
\item The proof term transformation from an existing proof reuse tool can be generalized
to build such a proof repair tool, and the result can handle many different kinds of changes (Section~\ref{sec:key2}).
\item The transformed proof terms can then be translated back to tactics (Section~\ref{sec:decompiler}).
\end{enumerate}

These insights informed our design of 
\toolname\footnote{Real name withheld for double-blind review.} (Configurable Approach to Repairing and Refactoring Outdated Tactics), a plugin for Coq 8.8.
\toolname combines a configurable program transformation over proof terms % TODO doesn't quite match current organization
with search procedures to configure the program transformation,
and a prototype decompiler from proof terms back to tactics.
The result is a proof repair tool that:

\begin{enumerate}
\item supports many different classes of changes, and
\item produces tactic scripts as part of better workflow integration.
\end{enumerate}
Our main technical advances are techniques for transforming proof terms directly to repair broken proofs, while our decompiler up to the tactic level is important for usability in the Coq setting.
We demonstrate flexibility and usability with four case studies (Section~\ref{sec:search}), which show that \toolname:

\begin{enumerate}
\item has helped an industrial proof engineer integrate Coq with a company proof engineering workflow and write proofs about an implementation
of the TLS Handshake Protocol,
\item can simplify dependently-typed programming and proving,
\item can support variants of a repair benchmark from a user study of Coq proof engineers, and
\item can help port functions and proofs from unary to binary numbers.
\end{enumerate}
Our experiences drive ideas (Section~\ref{sec:discussion}) that open the door to better proof engineering tools.

