\section{Decompiling Proof Terms to Tactics}
\label{sec:decompiler}

\textbf{Transform} produces a proof term,
while the proof engineer typically writes and maintains proof scripts made up of tactics.
We improve user experience thanks the realization that, since Coq's proof term language Gallina is very structured,
we can decompile these gallina terms to Ltac proof scripts for the proof engineer to maintain. In other words:

\begin{quote}
\textbf{Insight 3}: The transformed proof terms can then be translated back to tactics.
\end{quote}

The \textbf{Decompile} component implements a prototype of this translation.
This decompiler prototype has shown early promising results.
For example, it produced the automatically generated tactic proof for \lstinline{rev_app_distr} 
in Section~\ref{sec:overview}, as well as the tactic proofs of \lstinline{section}
and \lstinline{retraction} in Section~\ref{fig:equivalence}.

The prototype decompiler works by decompiling proof terms to candidate proof scripts that 
use a predefined set of Ltac tactics (Section~\ref{sec:first}).
It then pretty-prints and helps clean up that proof script for the proof engineer (Section~\ref{sec:second}).
The proof engineer can massage the final result as desired into a proof script that both works and is maintainable.

\subsection{Decompilation}
\label{sec:first}

\begin{figure}
\small
\begin{grammar}
<i> $\in \mathbbm{N}$, <v> $\in$ Vars, <s> $\in$ \{ Prop, Set, Type<i> \}

<t> ::= <v> | <s> | $\Pi$ (<v> : <t>) . <t> | $\lambda$ (<v> : <t>) . <t> | <t> <t> | \\
Ind (<v> : <t>)\{<t>,\ldots,<t>\} | Constr (<i>, <t>) | Elim(<t>, <t>)\{<t>,\ldots,<t>\} | Let (<v>, <t>, <t>, <t>)
\end{grammar}
\caption{Syntax for CIC$_{\omega}$ extended with let expressions.}
\label{fig:gallinasyntax}
\end{figure}

The input language for the implementation of \textbf{Decompile} is Gallina, the proof term language in Coq.
As with \textbf{Transform}, we present the semantics using an extension of CIC$_{\omega}$ (Figure~\ref{fig:gallinasyntax}).
The extension adds dependent let expressions, taking it one step closer to Gallina.
It does not include any of the configuration parts from \textbf{Transform}, since these just compile down to proof terms in CIC$_{\omega}$.
We assume all names are fresh. %, but the implementation generates fresh names automatically.
We assume an inductive type $=$ for propositional equality with symmetry proof \lstinline{eq_sym},
as well an inductive types $\vee$ and $\wedge$ for disjunction and conjunction, as in Coq.
We assume the existence of an oracle $\subseteq$ that returns true when a Gallina term is a syntactic subterm of another term.

\begin{figure}
\small
\begin{grammar}
<d> $\in$ \{ $\leftarrow$, $\rightarrow$ \}, <v> $\in$ Vars, <t> $\in$ CIC$_{\omega}$

<p> ::= Intro <v> | Intros \{<v>,\ldots,<v>\} | Revert \{<v>, \ldots, <v>\} | Pose <t> <v> | \\
Apply <t> | Rewrite <d> <t> | Induction <t> \{ <p>, \ldots, <p> \} | Split \{ <p>, <p> \} | \\
ApplyIn <t> <t> \{ <p>, \ldots, <p> \} | RewriteIn <d> <t> <t> \{ <p>, \ldots, <p> \} | \\
Reflexivity | Simpl | Left | Right | Symmetry | <p> . <p>
\end{grammar}
\caption{Syntax for a predefined set of Ltac tactics.}
\label{fig:ltacsyntax}
\end{figure}

The output language comes from a predefined set of tactics in Ltac, the proof script language for Coq.
The grammar for this set of Ltac tactics is in Figure~\ref{fig:ltacsyntax}.
Note that Ltac tactics can refer to Gallina terms (here extended CIC$_{\omega}$ terms),
and the semantics of Ltac depends on the semantics of Gallina and on search procedures written in OCaml.
We do not attempt to formalize the semantics of even a subset of Ltac.

\begin{figure}
\begin{mathpar}
\mprset{flushleft}
\small
\hfill\fbox{$\Gamma$ $\vdash$ $t$ $\Rightarrow$ $p$}\\

\inferrule[Intro]
  { \Gamma,\ n : T \vdash b \Rightarrow p }
  { \Gamma \vdash \lambda (n : T) . b \Rightarrow \mathrm{Intro}\ n.\ p }

\inferrule[Symmetry]
  { \Gamma \vdash H \Rightarrow p }
  { \Gamma \vdash \mathtt{eq\_sym}\ H \Rightarrow \mathrm{Symmetry}.\ p } \\

\inferrule[Rewrite]
  { \Gamma \vdash H_2 \Rightarrow p }
  { \Gamma \vdash \mathrm{Elim}(\mathtt{eq\_sym}\ H_1,\ P) \{ x,\ H_2,\ y \} \Rightarrow \mathrm{Rewrite} \rightarrow H_1.\ p }

\inferrule[Rewrite-By]
  { \Gamma \vdash H_2 \Rightarrow p }
  { \Gamma \vdash \mathrm{Elim}(H_1,\ P) \{ x,\ H_2,\ y \} \Rightarrow \mathrm{Rewrite} \leftarrow H_1.\ p }

\inferrule[Induction]
  { \\ }
  { \\ } \\ % TODO needs revert

\inferrule[Left]
  { \Gamma \vdash H \Rightarrow p }
  { \Gamma \vdash \mathrm{Constr}(0,\ \vee)\ H \Rightarrow \mathrm{Left}.\ p }

\inferrule[Right]
  { \Gamma \vdash H \Rightarrow p }
  { \Gamma \vdash \mathrm{Constr}(1,\ \vee)\ H \Rightarrow \mathrm{Right}.\ p }

\inferrule[Split]
  { \Gamma \vdash l \Rightarrow p \\ \Gamma \vdash r \Rightarrow q }
  { \Gamma \vdash \mathrm{Constr}(0,\ \wedge)\ l r \Rightarrow \mathrm{Split} \{ p, q \}.\ }

\inferrule[Rewrite-In] % TODO needs cases somehow
  { \Gamma \vdash H_2 \nsubseteq b \\ \Gamma,\ n := \mathrm{Elim}(H_1,\ P) \{ x,\ H_2,\ y \} : T \vdash b \Rightarrow p }
  { \Gamma \vdash \mathrm{Let}(n,\ \mathrm{Elim}(H_1,\ P) \{ x,\ H_2,\ y \},\ T,\ b) \Rightarrow \mathrm{RewriteIn} \rightarrow H_1\ H_2.\ p }

\inferrule[Rewrite-In-By] % TODO needs cases somehow
  { \Gamma \vdash H_2 \nsubseteq b \\ \Gamma,\ n := \mathrm{Elim}(\mathtt{eq\_sym}\ H_1,\ P) \{ x,\ H_2,\ y \} : T \vdash b \Rightarrow p }
  { \Gamma \vdash \mathrm{Let}(n,\ \mathrm{Elim}(\mathtt{eq\_sym}\ H_1,\ P) \{ x,\ H_2,\ y \},\ T,\ b) \Rightarrow \mathrm{RewriteIn} \leftarrow H_1\ H_2.\ p }

\inferrule[Apply-In] % TODO needs cases somehow
  { \Gamma \vdash H \nsubseteq b \\ \Gamma,\ n := f\ H : T \vdash b \Rightarrow \vec{p}  }
  { \Gamma \vdash \mathrm{Let}(n,\ f\ H,\ T,\ b) \Rightarrow \mathrm{ApplyIn}\ f\ H.\ p }

\inferrule[Pose]
  { \Gamma \vdash n \subseteq b \\ \Gamma,\ n := t : T \vdash b \Rightarrow p }
  { \Gamma \vdash \mathrm{Let}(n,\ t,\ T,\ b) \Rightarrow \mathrm{Pose}\ t\ n.\ p }

\inferrule[Subgoal]
  { \\ }
  { \Gamma \vdash t \Rightarrow \mathrm{Apply}\ t }

\inferrule[Apply]
  { \\ }
  { \Gamma \vdash t \Rightarrow \mathrm{Apply}\ t }
\end{mathpar}
\caption{Decompiler semantics.}
\label{fig:someantics}
\end{figure}

Figure~\ref{fig:someantics} shows the semantics of the decompiler.
The decompiler accepts a proof term and generates a candidate Ltac proof script that attempts to prove the same theorem.
The baseline for success of the decompiler is the naive proof script that applies the entire proof term with the \lstinline{apply} tactic.
Such a proof script will always work, but will often be unreadable.
The decompiler defaults to this baseline behavior when it cannot find a suitable candidate proof script (\textsc{Apply}).

Otherwise, the goal of the decompiler is to improve on that baseline as much as possible,
or else produce a candidate proof script that is close enough that the proof engineer can manually massage it into something that
both works and is maintainable.
It does this by recursing over the proof term and constructing an Ltac proof script using a predefined set of tactics.

impl details: non-deterministic and abstracts away some things, like generating several subgoals vs. applying whole thing at once.
fresh names.

\paragraph{Introduction}
Lambda abstractions correspond to assumptions of hypotheses. Thus, each abstraction generates an “intro” tactic, adding a new hypothesis into the environment. The algorithm recurses on the body of the abstraction.

\paragraph{Rewriting}
Applications of the equality eliminators (eq_ind, eq_rec, eq_rect, eq_ind_r, eq_rec_r, eq_rect_r) generate a single “rewrite” tactic. In an Ltac proof, rewrite accepts a proof of equality between two terms and transforms the goal. The following tactics must prove the new goal. The decompiler generates a rewrite of the equality (the sixth argument of the eliminator) and recurses on the new goal (the fourth argument). If the eliminator is without the “_r”, then it is written “rewrite <-“ indicating the direction of the equality. (???)

\paragraph{Induction}
Applications of induction eliminators are deconstructed into a proof of each case, arguments to the motive, and the value we perform induction on.
The position of the inducted value (hard time explaining this): Pos = \# of arguments … – pms + 1 (???)
Following the inducted value are additional arguments to the motive. A “revert” tactic is inserted for each such hypothesis before induction. This forgets the hypotheses by adding them as arguments to the goal, producing a motive requiring these arguments exactly, and so they must be re-introduced in each case.

\paragraph{Left}
Application of \lstinline{or_introl}, constructing a logical or. A \lstinline{left} tactic is generated, transforming the goal to be the left side of the disjunction, and we recurse on the given proof.
Vs. (template-y description)
\lstinline{@or_introl A B H : A \/ B}
Generate \lstinline{left.}
Recurse on \lstinline{H.}

\paragraph{Right}
Application of \lstinline{or_intror}, constructing a logical or. A \lstinline{right} tactic is generated, transforming the goal to be the left side of the disjunction, and we recurse on the given proof.

\paragraph{Split}
Application of \lstinline{conj} constructing a logical and. A \lstinline{split} tactic is generated, creating a goal for each side of the conjunction, and we recurse on both proofs, generating the left side first.

\paragraph{Symmetry}

\paragraph{Rewrite In}
Rewrite-in transforms an existing hypothesis by binding a new hypothesis to replace all occurrences of the original in the remainder of the proof.
\lstinline{let _ : _ := eq_ind _ _ _ H2 _ H1 in _} where
		H2 is a hypothesis in context,
		H2 doesn’t occur in the body.
		Generate \lstinline{rewrite H1 in H2}. Recurse on body.

\paragraph{Apply In}
Apply-in transforms a hypothesis by applying a function to it, rebinding its type to the result of the function.
		In general,
		\lstinline{let _ : _ := f H in _} where
		H is a hypothesis in context,
		H doesn’t occur in the body.
		Generate  \lstinline{apply f in H}. Recurse on body.
		Unless we have,
		\lstinline{let H2 : _ := f H1 in H2 _} where
function \lstinline{f} expects additional arguments after \lstinline{H1}.
Performing \lstinline{apply f in H1}, Coq transforms the goal to be the result type of \lstinline{f}, and creates additional goals for arguments required after H1. Thus, we recurse on H2 and all following arguments it’s applied to.

\paragraph{Pose}
Pose is a catch-all for let-expressions. It explicitly binds a new name to a value.
\lstinline{let A : B := C in D} generates \lstinline{pose C as A}, recurse on the body.

\subsection{Cleanup \& Printing}
\label{sec:second}

Pretty printing at the very end.
Collapse multiple \lstinline{intro}s of several assumptions into a single \lstinline{intros} tactic assuming multiple hypotheses.
Replace all \lstinline{apply eq_refl} with the \lstinline{reflexivity} tactic.
\lstinline{simpl} before \lstinline{rewrite} (for now just always when we do induction, but eventually can be smarter based on motive) (technically not
in second pass yet, but easier conceptually).
Cool things we could do with this: use original tactics, semicolons. Apply just the function name instead of the whole application (need to try it out, this pass is a good place to try it out). Morphisms. Decision procedures.

take user input here,

not same tactics as original

not perfect




