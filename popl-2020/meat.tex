\section{Correct Art}

It's true that you can squint and view non-semantics-preserving changes as equivalence-preserving changes,
but you need to pick the right equivalence, then instantiate the algorithm to that equivalence.
You want this equivalence and the transformation you choose for eliminators and consructors to be both correct and useful.
Making it useful is an art, but we can at least make sure your art is correct.

We define correctness criteria for the transformation: needs to preserve equality up to univalent transport, and also needs to
preserve definitional equalities.
We then define a set of transformation rules that are generic across equivalences so long as the correctness criteria hold.
We prove this.

Next, for the four classes of equivalences we support (maybe more if we have time), we define the constructor, eliminator, and identity rules.
We prove that each of these satisfies the correctness criteria.
Our implementation also (or alternatively, depending on how much time we have) generates these proofs on an ad-hoc basis because
the general proof isn't possible within Coq.

Note about decidability of matching: when all of this is correct, what this means is that you \textit{can} always
run one of the transformation rules. But that doesn't mean you \textit{should}. Depends what the user wants,
and in some cases, would not terminate (refinement types, unpacking indexed types). Implementation section will
discuss how we actually decide which ones to run so user doesn't need to apply transport by hand over and over again,
and discussion section describes some cool ideas for doing this nicely with type-based search in the future.

\subsection{Correctness Criteria}

I suspect the eliminator transformations are correct when:

\begin{enumerate}
\item they preserve the univalent relation
\item they preserve definitional equalities
\end{enumerate}

Nicolas proved the first of these a while ago
for the equivalence in the DEVOID ITP paper.\footnote{\url{https://github.com/CoqHott/univalent_parametricity/commit/7dc14e69942e6b3302fadaf5356f9a7e724b0f3c}}
The statement is that the old and new eliminator variants are related along the univalent parametric relation.
Here are some examples.
We (hopefully) extend DEVOID to generate this proof automatically for each pair of types.
We (maybe) prove the more general versions below. 
We (hopefully) show that the transformation rules actually are correct when these two criteria hold.

For the second one we need not just an eliminator rule but also an identity rule.
DEVOID assumed primitive projections which let them get away without thinking of this,
but then had this weirdly ad-hoc ``repacking'' thing in their implementation.
It turns out this is just a more general identity rule, which basically says what
the identity function should lift to so that the transformation preserves definitional equalities.
Actually deciding when to run this rule is one of the biggest challenges in practice,
so we'll talk about that more in the implementation section.

\subsection{Four Transformations}

Here are the eliminator and identity rules for our four implemented transformations.

\subsection{Transformation Rules}

Here are the general rules, adapted from DEVOID.
I'll explain later and add back the common definition and define the custom eliminators ``DepElim'' and so on.

Note that now we define the types $A$ and $B$ to take all of the same arguments, so for example for the algebraic
example with \lstinline{list} and \lstinline{vector}, $A$ is \lstinline{fun (T : Type) => list T} while $B$
is \lstinline{fun (T : Type) => sigT (fun (n : nat) => vector T n)}. When we lift terms $a$ and $b$ of that type
we implicitly lift their types $A$ and $B$ and so their parameters. The eliminator, identity, and constructor rules
depend on this since they are different by type.

Given what it means to be correct, I'm not sure if small-step will make more sense here.
Also some of the rules are preliminary and will need tweaking.
Especially coherence and its relation to identity and how to capture things like \lstinline{eq_refl n}.
Right now I omit coherence because in theory it should be handled by the eliminator rule.
I'm also removing internalize because I think we should handle that inside of the constructor lifting, or it should be handled
by the eliminator rule, the identity rule, and the application rule.
But really need to consider cases like \lstinline{eq_refl n}.
May have something to do with parameterized inductive types.
In equivalence rule, we lift $A$ to $B$, but implicitly this is lifting the functions that take parameters and return $A$ or $B$,
and the arguments are lifted by the application rule.
Also this is only one direction but just flip for the other direction and make retraction into section.

\begin{figure}
\begin{mathpar}
\mprset{flushleft}
\small
\hfill\fbox{$\Gamma$ $\vdash$ $t$ $\Uparrow$ $t'$}\\

\inferrule[Lift-Elim]
  { \Gamma \vdash p_{a} \Uparrow_E p' \\ \Gamma \vdash \vec{f_{a}}\phantom{l} \Uparrow_E \vec{f}'  \\\\
    \Gamma \vdash p' \Uparrow p_b \\ \Gamma \vdash \vec{f}' \Uparrow \vec{f_b} \\ \Gamma \vdash a \Uparrow b }
  { \Gamma \vdash \mathrm{DepElim}(a,\ p_{a}) \vec{f_{a}} \Uparrow \mathrm{DepElim}(b,\ p_b) \vec{f_{b}} }

\inferrule[Lift-Identity]
  { \Gamma \vdash a \Uparrow b }
  { \Gamma \vdash \mathrm{IdEta}(a) \Uparrow \mathrm{IdEta}(b) }

\inferrule[Lift-Constr]
{ (\uparrow (\mathrm{DepConstr}(j,\ A)\ \vec{t}_{a}))_{\beta\delta\iota} \Uparrow t' \\\\ \Gamma \vdash t' \Uparrow t'' } %\\
{ \Gamma \vdash \mathrm{DepConstr}(j,\ A)\ \vec{t}_{a} \Uparrow t'' }

\inferrule[Retraction]
{ \\ }
{ \Gamma \vdash\ \downarrow\ \Uparrow \lambda (b : B) . \mathrm{IdEta}(b) }

\inferrule[Equivalence]
  { \\ }
  { \Gamma \vdash A\ \Uparrow B }

\inferrule[Constr]
{ \Gamma \vdash T \Uparrow T' \\ \Gamma \vdash \vec{t} \Uparrow \vec{t'} }
{ \Gamma \vdash \mathrm{Constr}(j,\ T)\ \vec{t} \Uparrow \mathrm{Constr}(j,\ T')\ \vec{t'} }

\inferrule[Ind]
  { \Gamma \vdash T \Uparrow T' \\ \Gamma \vdash \vec{C} \Uparrow \vec{C'}  }
  { \Gamma \vdash \mathrm{Ind} (\mathit{Ty} : T) \vec{C} \Uparrow \mathrm{Ind} (\mathit{Ty} : T') \vec{C'} }

\inferrule[Elim]
  { \Gamma \vdash c \Uparrow c' \\ \Gamma \vdash Q \Uparrow Q' \\ \Gamma \vdash \vec{f} \Uparrow \vec{f'}}
  { \Gamma \vdash \mathrm{Elim}(c, Q) \vec{f} \Uparrow \mathrm{Elim}(c', Q') \vec{f'}  }

%% Application
\inferrule[App]
 { \Gamma \vdash f \Uparrow f' \\ \Gamma \vdash t \Uparrow t'}
 { \Gamma \vdash f t \Uparrow f' t' }

% Lamda
\inferrule[Lam]
  { \Gamma \vdash T \Uparrow T' \\ \Gamma,\ t : T \vdash b \Uparrow b' }
  {\Gamma \vdash \lambda (t : T).b \Uparrow \lambda (t : T').b'}

% Product
\inferrule[Prod]
  { \Gamma \vdash T \Uparrow T' \\ \Gamma,\ t : T \vdash b \Uparrow b' }
  {\Gamma \vdash \Pi (t : T).b \Uparrow \Pi (t : T').b'}
\end{mathpar}
\caption{Generic lifting algorithm.}
\label{fig:final}
\end{figure}


\subsection{Correctness}

Here's the proof that as long as the correctness criteria hold, it's OK to take any of those steps.
Same definition as DEVOID paper for correctness but note we just consider one step at a time since
it's very undecidable to decide which ones to run. The implementation section talks about how we
decide this in practice.



