\section{A Simple Motivating Example}
\label{sec:overview}

\begin{figure}
\begin{minipage}{0.46\textwidth}
   \lstinputlisting[firstline=1, lastline=3]{listswap.tex}
\end{minipage}
\hfill
\begin{minipage}{0.46\textwidth}
   \lstinputlisting[firstline=5, lastline=7]{listswap.tex}
\end{minipage}
\vspace{-0.3cm}
\caption{The updated \lstinline{list} (right) is the old \lstinline{list} (left) with its two constructors swapped (\codediff{orange}).}
\label{fig:listswap}
\end{figure}

\toolname is a tool for proof repair that is available on Github.\footnote{Link withheld for double-blind review.}
Consider a simple example of using \toolname: fixing broken list proofs after swapping the two constructors of a list (Figure~\ref{fig:listswap}).
Even such a simple change can cause trouble in existing proofs, like this proof from the Coq standard library:\footnote{We use induction instead of pattern matching.}

\begin{lstlisting}
Lemma rev_app_distr {A : Type} : $\forall$ (x y : list A), rev (x ++ y) = rev y ++ rev x.(@\vspace{-0.04cm}@)
Proof.(@\vspace{-0.04cm}@)
  induction x as [| a l IHl].(@\vspace{-0.04cm}@)
  induction y as [| a l IHl].(@\vspace{-0.04cm}@)
  simpl. auto.(@\vspace{-0.04cm}@)
  simpl. rewrite app_nil_r; auto.(@\vspace{-0.04cm}@)
  intro y. simpl.(@\vspace{-0.04cm}@)
  rewrite (IHl y). rewrite app_assoc; trivial.(@\vspace{-0.04cm}@)
Qed.
\end{lstlisting}
This theorem says that appending two lists and reversing the result behaves the same way as appending
the reverse of the second list onto the reverse of the first list.
When we change the \lstinline{list} type, our proof no longer works.
%This theorem statement \lstinline{rev_app_distr} defined over the old version of \lstinline{list} is our \textit{old specification}.
%When we change the \lstinline{list} type, we get the \textit{new specification}.
%But the \textit{old proof} or tactic script no longer works with this new specification.
To repair this proof with \toolname, we just run this command:

\begin{lstlisting}
Repair Old.list New.list in rev_app_distr.
\end{lstlisting}
assuming our old and new list types from Figure~\ref{fig:listswap} are in separate modules \lstinline{Old} and \lstinline{New}.
This produces an updated proof script that succeeds (Figure~\ref{fig:auto}),
where the dependencies (\lstinline{rev}, \lstinline{++}, \lstinline{app_assoc}, and \lstinline{app_nil_r}) have
also been updated automatically.
If we'd like, we can manually modify this to something that more closely matches the style of the original proof script:

\begin{lstlisting}
Proof.(@\vspace{-0.04cm}@)
  induction x as [a l IHl|].(@\vspace{-0.04cm}@)
  intro y. simpl.(@\vspace{-0.04cm}@)
  rewrite (IHl y). rewrite app_assoc; trivial.(@\vspace{-0.04cm}@)
  induction y as [a l IHl|].(@\vspace{-0.04cm}@)
  simpl. rewrite app_nil_r; auto.(@\vspace{-0.04cm}@)
  simpl. auto.(@\vspace{-0.04cm}@)
Qed.
\end{lstlisting}
We can even repair the entire list module from the Coq standard library all at once by running the \lstinline{Repair module}
command; the results of this are in \lstinline{Swap.v}.\footnote{Links to repository withheld for double-blind review.} % TODO

\begin{figure}
\codeauto{\lstinputlisting{overviewproof.tex}}
\vspace{-0.3cm}
\caption{The automatically (denoted by $\codeauto{light blue}$) repaired proof of \lstinline{rev_app_distr} that \toolname produces.}
\label{fig:auto}
\end{figure} % TODO revisit all generated tactic proofs with final decompiler

The key to success here is that \toolname does not even attempt to update the poorly structured proof script directly.
Even for the simple proof script above, this would not be straightforward: Grouping tactics by line, there are $6! = 620$
permutations of this proof script.
It is not clear which lines to swap since these tactics do not have a semantics beyond the meaning imposed by evaluation.
Furthermore, just swapping lines is not enough: even for such a simple change, we must also swap
arguments, so \lstinline{induction x as [| a l IHl]} becomes \lstinline{induction x as [a l IHl|]}.
Handling even swapping constructors this way would require a specific search procedure that would not generalize to other changes.
\citet{robert2018} describes the challenges of repairing tactics directly in detail.

Instead, \toolname takes advantage of the fact that Coq's \textit{proof term} language Gallina is well structured.
Coq compiles each proof script to a proof term---\toolname repairs that term.
\toolname then decompiles the repaired proof term back to a proof script that the user can maintain.
In this example, \toolname transforms the proof term Coq compiles \lstinline{rev_app_distr} to,
and then decompiles that transformed proof term to the tactic script in Figure~\ref{fig:auto}.
It tries only $1$ rather than $620$ candidates. 

While this is a simple change, this same workflow can get us much more.
Section~\ref{sec:search} shows how we have used \toolname to support industrial integration with Coq,
write dependently-typed functions and proofs with little user effort,
support examples from a benchmark from Coq proof engineers,
and port proofs between unary and binary natural numbers.




