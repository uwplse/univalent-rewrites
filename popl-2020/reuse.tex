\section{Proof Repair}
\label{sec:key1}

%Proof refactoring and proof repair are similar problems: both refer to adapting proofs in response to changes
%in specifications. Refactoring refers to semantics-preserving changes, and repair refers to non-semantics-preserving
%changes.
\textit{Proof repair} is the problem of updating a broken proof in response to a change in a program or specification~\cite{PGL-045, pumpkinpatch}.
We can view this as a form of 
\textit{proof reuse}~\cite{Ringer2019, felty1994generalization, caplan1995logical, pons2000generalization, johnsen2004theorem}, % TODO consider citation list
or reusing proofs about one specification to derive proofs about another specification.
The difference is that in standard proof reuse, both of these specifications continue to exist.
In contrast, proof repair is the process of reusing proofs across \textit{two versions of a single specification},
only one of which---the new version---continues to exist.

\begin{quote}
\textbf{Insight 1}:
Proof repair is a form of proof reuse (Section~\ref{sec:repair}), with the additional
challenge that the specification about which
we are reusing proofs ceases to exist.
The key to supporting proof repair is to build a proof reuse
tool that can handle that additional challenge (Section~\ref{sec:time}).
\end{quote}

\subsection{Repair as Reuse across Equivalences}
\label{sec:repair}

Proof repair can be viewed as a form of proof reuse. 
In the \lstinline{list} example from Section~\ref{sec:overview}, for example, \toolname
reused the old proof of \lstinline{rev_app_distr} defined over \lstinline{Old.list}
to generate the new proof of \lstinline{rev_app_distr} defined over \lstinline{New.list}.
Since this change was simple, this required no additional information from the user, and the resulting functions
and proofs behaved exactly the same way.

\begin{figure}
\begin{minipage}{0.48\textwidth}
\begin{lstlisting}
(@\codeauto{f}@) T (l : Old.list T) : New.list T :=
  Old.list_rect T
    (fun (l : Old.list T) => New.list T)
    New.nil
    (fun (t : T) _ (IHl : New.list T) =>
      New.cons T t IHl)
    l.

Lemma (@\codeauto{section}@):
  $\forall$ T (l : Old.list T), (@\codeauto{g}@) T ((@\codeauto{f}@) T l) = l.
Proof.
  intros T l. symmetry. induction l.
  - reflexivity.
  - simpl. rewrite <- IHl. reflexivity.
Defined.
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\begin{lstlisting}
(@\codeauto{g}@) T (l : New.list T) : Old.list T :=
  New.list_rect T
    (fun (l : New.list T) => Old.list T)
    (fun (t : T) _ (IHl : Old.list T) =>
      Old.cons T t IHl)
    Old.nil
    l.

Lemma (@\codeauto{retraction}@):
  $\forall$ T (l : New.list T), (@\codeauto{f}@) T ((@\codeauto{g}@) T l) = l.
Proof.
  intros T l. symmetry. induction l.
  - simpl. rewrite <- IHl. reflexivity.
  - reflexivity.
Defined.
\end{lstlisting}
\end{minipage}
\caption{Two functions between \lstinline{Old.list} and \lstinline{New.list} (top) that form an equivalence (bottom).}
\label{fig:equivalence}
\end{figure}

More formally, \toolname was able to find a pair of two functions that map between \lstinline{Old.list}
and \lstinline{New.list} and prove that they are mutual inverses, generating the functions and tactic
proofs in Figure~\ref{fig:equivalence} automatically.
\toolname could then use that information to configure its proof term transformation to update
functions and proofs about \lstinline{Old.list} to functons and proofs about \lstinline{New.list} with
the same behavior.

Whenever there exist two functions between two types that are mutual inverses,
there is a \textit{type equivalence}~\cite{univalent2013homotopy} between them, denoted $\simeq$.

\begin{lstlisting}
Old.list $\simeq$ New.list
\end{lstlisting}
Repair corresponds to proof reuse across these equivalences.
This can support not just simple changes, but also changes in which the proof engineer adds or removes information.
In that case, the equivalence that the tool ports functions and proofs along
is an equivalence between \textit{refinements}.
It is up to the proof engineer to supply the additional information in order to construct proofs about the refinement.

\begin{figure}
\begin{minipage}{0.40\textwidth}
   \lstinputlisting[firstline=1, lastline=4]{listtovect.tex}
\end{minipage}
\hfill
\begin{minipage}{0.58\textwidth}
   \lstinputlisting[firstline=6, lastline=9]{listtovect.tex}
\end{minipage}
\caption{A vector (right) is a list (left) indexed by its length.}
\label{fig:listtovect}
\end{figure}

Consider an example from \textsc{Devoid}: changing a list to a length-indexed vector (Figure~\ref{fig:listtovect}).
\textsc{Devoid} is able to repair proofs about lists to proofs about \textit{vectors of some length}, since:

\begin{lstlisting}
list T $\simeq$ $\Sigma$ (n : nat) . vector T n.
\end{lstlisting}
This is enough to automatically repair a lemma about lists:

\begin{lstlisting}
$\forall$ {A B} (l1 : list A) (l2 : list B),
  zip_with pair l1 l2 = zip l1 l2.
\end{lstlisting}
to a lemma about vectors of some length:

\begin{lstlisting}
$\forall$ {A B} (l1 : (@\codediff{$\Sigma$(n : nat).vector A n}@)) (l2 : (@\codediff{$\Sigma$(n : nat).vector B n}@)),
  zip_with pair l1 l2 = zip l1 l2.
\end{lstlisting}
recursively updating dependencies \lstinline{zip} and \lstinline{zip_with}.
It is not enough, however, to help the proof engineer get from that to a proof about vectors \textit{at a particular index}:

\begin{lstlisting}
$\forall$ {A B} (@\codediff{n}@) (l1 : (@\codediff{vector A n}@)) (l2 : (@\codediff{vector B n}@)),
  zip_with pair (@\codediff{n}@) l1 l2 = zip (@\codediff{n}@) l1 l2.
\end{lstlisting}

More desirable is a repair that takes us from lists \textit{at a particular length} to vectors of that length:

\begin{lstlisting}
{ l : list T | length l = n } $\simeq$ vector T n.
\end{lstlisting}
\toolname can handle both of these changes.
Practically, when the proof engineer changes specifications to refer to \lstinline{vector} instead of \lstinline{list},
to fix her functions and proofs, she must additionally prove invariants about the lengths of her lists.
\toolname makes it easy to separate out that proof obligation, and then automates the rest.

\subsection{A Tool for Proof Repair}
\label{sec:time}

The problem of proof reuse across equivalences is known as \textit{transport}. % TODO cite
Thus, any tool that can repair proofs implements transport across the classes
of equivalences that it supports---and so can handle proof reuse as well.
But not every proof reuse tool or transport method can support proof repair.
A proof repair tool must produce proofs
that no longer refer in any way to the old specification, since the old specification no longer exists.

The goal of a proof repair tool is, in essence, to
define a transport method over a broad set of changes that
removes references to the old specification, rather than converting back and forth
like standard transport methods.
For example, the updated proof of \lstinline{rev_app_distr} and its dependencies
from Section~\ref{sec:overview} refer only to \lstinline{New.list} and not to \lstinline{Old.list}.
The proof inducts directly over \lstinline{New.list} and never, at any point, converts to an \lstinline{Old.list}.
Thus, we need \lstinline{Old.list} around only until we call the \lstinline{Repair} command;
after that, we can remove the type and all of the functions and proofs about it, and replace them all with
our functions and proofs about \lstinline{New.list}.

\toolname accomplishes this using a configurable proof term transformation (Section~\ref{sec:key2}).
The proof term transformation implements transport across equivalences, but in a way that removes
references to the old type.
The configuration corresponds to a particular equivalence, and tells the proof term transformation how to transform
constructors, eliminators, and equalities.
Section~\ref{sec:search} includes many example configurations as applied to real proof reuse and repair scenarios.


