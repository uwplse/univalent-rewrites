\section{Problem Definition}
\label{sec:key1}

\toolname is a tool for \textit{proof repair}.
Proof repair is the problem of updating a broken proof in response to a change in a program or specification~\cite{PGL-045, pumpkinpatch}---in the
case of \toolname, a change in a type definition that corresponds to an equivalence (Section~\ref{sec:scope}).

We can view proof repair as a form of 
\textit{proof reuse}~\cite{Ringer2019, felty1994generalization, caplan1995logical, pons2000generalization, johnsen2004theorem}, % TODO consider citation list
or reusing proofs about one specification (say, from another library, or from within the same proof development)
to derive proofs about another specification.
The difference is that in standard proof reuse, both of these specifications continue to exist.
In contrast, proof repair is the process of reusing proofs across \textit{two versions of a single specification},
only one of which---the new version---must continue to exist.
That is, the old version of the specification may be removed after updating proofs to use the new version.

\begin{quote}
\textbf{Insight 1}:
Proof repair is a form of proof reuse---reusing proofs about one specification to derive proofs about another specification---with 
the additional challenge that one of the specifications may cease to exist (Section~\ref{sec:repair}).
The key to supporting proof repair is to build a proof reuse
tool that can handle that additional challenge (Section~\ref{sec:time}).
\end{quote}

\subsection{Scope: Type Equivalences}
\label{sec:scope}

\begin{figure*}
\codeauto{%
\begin{minipage}{0.48\textwidth}
\lstinputlisting[firstline=1, lastline=14]{equivproof.tex}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\lstinputlisting[firstline=16, lastline=30]{equivproof.tex}
\end{minipage}}
\vspace{-0.3cm}
\caption{Two functions between \lstinline{Old.list} and \lstinline{New.list} (top) that form an equivalence (bottom).}
\label{fig:equivalence}
\end{figure*}

\toolname supports a particular kind of repair: proof repair in response to certain changes in type definitions.
In particular, these changes in type definitions must correspond to \textit{type equivalences}~\cite{univalent2013homotopy},
or pairs of functions that map between two types and are mutual inverses.
Figure~\ref{fig:equivalence} shows a type equivalence between the two versions of \lstinline{list}
from Section~\ref{sec:overview}, Figure~\ref{fig:listswap} that \toolname discovered and proved automatically.
When such a type equivalence between two types exists, we say those types are \textit{equivalent} (denoted $\simeq$), for example:

\begin{lstlisting}
Old.list $\simeq$ New.list
\end{lstlisting}

All of the changes in Table~\ref{fig:changes} can be described by equivalences.
To give some more intuition for what kinds of changes can be described this way, we describe two changes below.

\subsubsection{Factoring out Constructors}
\label{sec:ex1}

\begin{figure}
\begin{minipage}{0.48\columnwidth}
\lstinputlisting[firstline=1, lastline=3]{equiv2.tex}
\end{minipage}
\hfill
\begin{minipage}{0.48\columnwidth}
\lstinputlisting[firstline=5, lastline=7]{equiv2.tex}
\end{minipage}
\vspace{-0.3cm}
\caption{The type \lstinline{J} (right) is \lstinline{I} (left) with \lstinline{A} and \lstinline{B} factored out to \lstinline{bool} (Coq standard library).}
\label{fig:equivalence2}
\end{figure}

Consider using \toolname to port functions and proofs across the change from the type \lstinline{I} to the type \lstinline{J} 
in Figure~\ref{fig:equivalence2}.
\lstinline{J} can be viewed as \lstinline{I} with its two constructors \lstinline{A} and \lstinline{B} pulled out to a
new hypothesis of type \lstinline{bool} for a single constructor.

With \toolname, the proof engineer can repair functions and proofs about \lstinline{I} to instead use \lstinline{J},
as long as she first configures \toolname to describe which constructor 
of \lstinline{I} maps to \lstinline{true} and which maps to \lstinline{false}.
This information about constructor mappings induces an equivalence \lstinline{I }$\simeq$\lstinline{ J}
along which \toolname repairs functions and proofs.

The file \href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/constr_refactor.v}{constr_refactor.v}
shows an example of this, mapping \lstinline{A} to \lstinline{true} and \lstinline{B} to false.
It uses \toolname to automatically repair functions and proofs over \lstinline{I}, like:

\begin{lstlisting}
Theorem demorgan_1 : $\forall$ (i1 i2 : I),(@\vspace{-0.04cm}@)
  neg (and i1 i2) = or (neg i1) (neg i2).(@\vspace{-0.04cm}@)
Proof.(@\vspace{-0.04cm}@)
  intros i1 i2.(@\vspace{-0.04cm}@)
  induction i1; auto.(@\vspace{-0.04cm}@)
Qed.
\end{lstlisting}
to corresponding functions and proofs over \lstinline{J}, like:

\begin{lstlisting}[backgroundcolor=\color{cyan!30}]
Theorem demorgan_1 : $\forall$ (j1 j2 : J),(@\vspace{-0.04cm}@)
  neg (and j1 j2) = or (neg j1) (neg j2).(@\vspace{-0.04cm}@)
Proof.(@\vspace{-0.04cm}@)
  intros j1 j2.(@\vspace{-0.04cm}@)
  induction j1 (@\codediff{as [b]. induction b as [ | ]}@); auto.(@\vspace{-0.04cm}@)
Qed.
\end{lstlisting}
These repaired functions and proofs refer to \lstinline{J} in place of \lstinline{I}.
Otherwise, they behave the same way as the functions and proofs over \lstinline{I} up to the equivalence between
\lstinline{I} and \lstinline{J}---Section~\ref{sec:repair} explains this intuition more formally.

\subsubsection{Adding a Dependent Index}
\label{sec:ex2}

At first glance, the word \textit{equivalence} may seem to imply that \toolname can support only changes in
which the proof engineer does not add or remove any information.
But equivalences are more powerful than they may seem.
For example, in cubical type theory, with the help of quotient types, it is possible to form an equivalence
from a relation, even when the relation itself is not an equivalence~\cite{angiuli2020internalizing}.

\toolname, of course, operates on Coq code, and Coq lacks quotient types.
It is possible to achieve a similar outcome and use \toolname for changes that add or remove information
whenever those change can be expressed as equivalences between $\Sigma$ types or between sum types.
The idea is, when possible, to separate out the new information
into a projection of a $\Sigma$ type, or into a constructor of a sum type.
Proofs about this new information become the proof obligation for the proof engineer,
and \toolname automates the rest.

\begin{figure*}
\begin{minipage}{0.40\textwidth}
   \lstinputlisting[firstline=1, lastline=4]{listtovect.tex}
\end{minipage}
\hfill
\begin{minipage}{0.58\textwidth}
   \lstinputlisting[firstline=6, lastline=9]{listtovect.tex}
\end{minipage}
\vspace{-0.3cm}
\caption{A vector (right) is a list (left) indexed by its length.}
\label{fig:listtovect}
\end{figure*}

Consider, for example, changing a list to a length-indexed vector (Figure~\ref{fig:listtovect}).
With the proof reuse tool \textsc{Devoid}~\cite{Ringer2019},
it is possible to repair proofs about lists to proofs about vectors of \textit{some} length, since:

\begin{lstlisting}
packed_vect T := $\Sigma$(n : nat).vector T n.
list T $\simeq$ packed_vector T.
\end{lstlisting}
This is enough to automatically repair a lemma about lists:

\begin{lstlisting}
$\forall$ {A B} (l1 : list A) (l2 : list B),(@\vspace{-0.04cm}@)
  zip_with pair l1 l2 = zip l1 l2.
\end{lstlisting}
to a lemma about vectors of some length:

\begin{lstlisting}
$\forall$ {A B} (l1 : (@\codediff{packed\_vect A}@)) (l2 : (@\codediff{packed\_vect B}@)),(@\vspace{-0.04cm}@)
  zip_with pair l1 l2 = zip l1 l2.
\end{lstlisting}
recursively updating dependencies \lstinline{zip} and \lstinline{zip_with}.
It is not enough, however, to help the proof engineer get from that to a proof about vectors \textit{of a particular length}:

\begin{lstlisting}
$\forall$ {A B} (@\codediff{n}@) (l1 : (@\codediff{vector A n}@)) (l2 : (@\codediff{vector B n}@)),(@\vspace{-0.04cm}@)
  zip_with pair (@\codediff{n}@) l1 l2 = zip (@\codediff{n}@) l1 l2.
\end{lstlisting}
\textsc{Devoid} leaves this step to the proof engineer.
\toolname, in contrast, can handle this step as well (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/examples/Example.v}{\lstinline{Example.v}}).
The key is to repair functions and proofs across this equivalence:

\begin{lstlisting}
$\Sigma$(l : list T).length l = n $\simeq$ vector T n.
\end{lstlisting}
From the proof engineer's perspective, when the proof engineer updates specifications from \lstinline{list} to \lstinline{vector},
to fix her functions and proofs, she must additionally prove invariants about the lengths of her lists.
\toolname makes it easy to separate out that proof obligation, then automates the rest.
%Section~\ref{sec:search} shows this and other case studies using \toolname to repair real proofs
%informed by the needs of proof engineers.

\subsection{Transport with a Twist}
\label{sec:repair}

Proof repair across type equivalences corresponds to a particular kind of proof reuse called \textit{transport},
with the twist that the specification about which we are reusing proofs may cease to exist.
A transport method takes an input term $t$ and produces an output term $t'$ that is \textit{equal up to transport}
along an equivalence $A \simeq B$ (denoted $t \equiv_{A \simeq B} t'$).
Informally, equality up to transport means that if $t$ is a function, then $t'$ behaves the same way modulo the equivalence;
if $t$ is a proof, then $t'$ proves the same theorem the same way modulo the equivalence.
For example, in Section~\ref{sec:overview}, the original append function \lstinline{++} over \lstinline{Old.list}
and the updated append function \lstinline{++} over \lstinline{New.list} that \toolname produces are
equal up to transport along the equivalence from Figure~\ref{fig:equivalence}, since:

\begin{lstlisting}
$\forall$ T (l1 l2 : Old.list T),
  swap T (l1 ++ l2) = (swap T l1) ++ (swap T l2).
\end{lstlisting}
by \lstinline{app_ok} in \href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/Swap.v}{Swap.v}.
The original \lstinline{rev_app_distr} is equal to the transformed proof along the same equivalence,
since it proves the same thing the same way as the transformed proof up to the same equivalence, and up to the changes in \lstinline{++}
and \lstinline{rev}.

Note that for any equivalent \A and \B, there can be many equivalences $A \simeq B$.
Equality up to transport is along a \textit{particular} equivalence, though we erase this in the notation.
Also note that, as Coq lacks univalence, and so equality up to transport cannot be stated in Coq in general,
this notation should be interpreted in the context of a univalent metatheory.
The formal details of equality up to transport in such a theory can be found in \citet{univalent2013homotopy}, and an approximation in Coq without univalence can be found in \citet{tabareau2017equivalences}.

Transport methods typically work by explicitly applying the functions that make up the equivalence to convert
inputs and outputs back and forth between equivalent types.
This approach would not work for repair, since it does not make it possible to remove the old specification.
The goal of a proof repair tool like \toolname is to define a transport method that
can remove references to the old specification, %rather than converting back and forth like standard transport methods.
%That way, the proof repair tool can produce proofs that no longer refer in any way to the old specification,
since the old specification may no longer exist.

Section~\ref{sec:overview} showed a simple case of this: \toolname
reused the proof of \lstinline{rev_app_distr} defined over \lstinline{Old.list}
to generate a new proof of \lstinline{rev_app_distr} defined over equivalent \lstinline{New.list}.
Furthermore, it did so in a way that removed all references to \lstinline{Old.list} in the proof
and in its dependencies.
That way, after calling \lstinline{Repair}, \lstinline{Old.list} could be removed.

\subsection{A Tool for Proof Repair Across Equivalences}
\label{sec:time}

\begin{figure*}
\begin{minipage}{0.52\textwidth}
\includegraphics[width=\linewidth]{workflowa.pdf}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\includegraphics[width=\linewidth]{workflowb.pdf}
\vspace{0.97cm}
\end{minipage}
\vspace{-0.4cm}
\caption{The two possible workflows for \toolname, using either automatic (left) or manual (right) configuration.}
\label{fig:system}
\end{figure*}

\toolname implements this transport with a twist using a proof term transformation.
The proof term transformation implements transport across equivalences,
but in a way that replaces references to the old type (in Section~\ref{sec:overview}, \lstinline{Old.list})
with references to the new type (in Section~\ref{sec:overview}, \lstinline{New.list}).

This proof term transformation takes as input an equivalence in a special form that we call a \textit{configuration}.
At a high level, a configuration is a deconstructed equivalence, split into parts that refer to the old type
and parts that refer to the new type, without converting back and forth.
The purpose of this deconstructed equivalence is to help the proof term transformation transport proofs across the equivalence in a 
way that removes references to the old type, all the while abstracting away the details specific to any 
given change in type (like permuting arguments to induction principles).
Section~\ref{sec:configurable} explains a configuration in more detial, and shows that every equivalence
induces a configuration.

The configuration can be supplied manually, or discovered automatically by a search procedure.
Figure~\ref{fig:system} shows how this comes together when the proof engineer invokes \toolname:

\begin{enumerate}
\item \toolname configures itself, either:
\begin{enumerate}
\item automatically (left), using \textbf{Configure} to discover the configuration, or
\item manually (right), by taking the configuration as an argument.
\end{enumerate}
\item The configured \textbf{Transform} transforms the old proof term into the new proof term.
\item \textbf{Decompile} produces a new proof script from the new proof term.
\end{enumerate}

The example in Section~\ref{sec:overview} uses automatic configuration. When we run the \lstinline{Repair} command,
\textbf{Configure} invokes a search procedure that automatically proves the equivalence in Figure~\ref{fig:equivalence},
then configures \textbf{Transform} using that equivalence.
\textbf{Transform} then ports the proof term that inducted over \lstinline{Old.list}
to induct over \lstinline{New.list}, and finally
\textbf{Decompile} produces the tactic script in light blue. %in Figure~\ref{fig:auto}.

There are currently four search procedures for automatic configuration implemented in \toolname (see Table~\ref{fig:changes}).
All four search procedures generate equivalence proofs as in Figure~\ref{fig:equivalence} automatically (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/src/automation/search/search.ml}{search.ml} and \href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/src/automation/search/equivalence.ml}{equivalence.ml}),
then configure (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/src/automation/lift/liftconfig.ml}{liftconfig.ml}) the transformation to those equivalences.
Manual configuration makes it possible
for the proof engineer to directly configure the transformation to any other equivalence,
even without a search procedure.
Section~\ref{sec:search} shows examples of both workflows applied to real proof reuse and repair scenarios.




