\section{Implementation}
\label{sec:impl}

The transformation abstracts a lot of the details needed to build a proof repair tool that reaches proof engineers,
and the mini decompiler abstracts a lot of the details that make Ltac so useful to proof engineers---and so painful to 
reason about automatically.
This section describes how we solved some of the implementation challenges that we encountered.
%for both the transformation (Section~\ref{sec:implementation}) and the decompiler (Section~\ref{sec:second}).
%Section~\ref{sec:discussion} describes some remaining challenges and our plans to address them. % in the future.

\subsection{Implementing the Transformation}
\label{sec:implementation}

\mysubsubsec{Termination \& Intent}
When the correctness criteria for a configuration hold and a subterm unifies with a configuration term, this suggests that \toolname \textit{can}
transform the subterm, but it does not necessarily mean that it \textit{should}.
In some cases, doing so would result in nontermination.
For example, if \B is a refinement of \A, then we can always run \textsc{Equivalence}
over and over again, forever.
%\textsc{Devoid} ruled out this case by simply prohibiting the case where \B refers to \A, but we found it sometimes
%useful to support this case.
We thus include some simple termination checks in our code~\circled{12}. % liftrules.ml

Even when termination is guaranteed, whether to transform a subterm depends on intent.
For example, our industrial proof engineer sometimes wished to port only some occurrences of \A,
especially when \A was a tuple that could appear elsewhere
with a different meaning.
\toolname has some support for this using an interactive workflow~\circled{13}. % minimal_records.v, but show this
%We helped the proof engineer do this by interacting with \toolname using a particular workflow.
%We plan to support this automatically using type-directed search in the future.

\mysubsubsec{From CIC$_{\omega}$ to Coq}
The implementation~\circled{4} % lift.ml
of the transformation handles language differences to scale from CIC$_{\omega}$ to Coq.
We use the existing \lstinline{Preprocess}~\cite{Ringer2019} command to turn pattern matching and fixpoints into 
eliminators.
We handle refolding of constants in constructors using \lstinline{DepConstr}.

\begin{figure}
\begin{lstlisting}
fun (@\codesimb{(y0 : list A)}@) =>(@\vspace{-0.04cm}@)
  (@\codesima{list_rect}@) _ _  (fun (@\codesima{a l IHl}@) =>(@\vspace{-0.04cm}@)
    (@\codesimc{eq_ind_r}@) _ (@\codesimd{eq_refl}@) (@\codesimc{(app_nil_r (rev l) (a::[]))}@))(@\vspace{-0.04cm}@)
    (@\codesime{eq_refl}@)(@\vspace{-0.04cm}@)
    (@\codesima{y0}@)(@\vspace{-0.04cm}@)
(@\vspace{-0.14cm}@)
- (@\codesimb{intro y0.}@)(@\vspace{-0.04cm}@)
  (@\codesima{induction y0 as [a l IHl|]}.@)(@\vspace{-0.04cm}@)
  + (@\codesimc{simpl. rewrite (app_nil_r (rev l) (a::[])).}@) (@\codesimd{auto.}@)(@\vspace{-0.04cm}@)
  + (@\codesime{auto.}@)(@\vspace{-0.04cm}@)
\end{lstlisting}
\vspace{-0.4cm}
\caption{Proof term (top) and decompiled proof script (bottom) for the base case of 
\lstinline{rev_app_distr} (Section~\ref{sec:overview}), with corresponding terms and tactics 
highlighted the same color.}
\label{fig:rainbow}
\end{figure}

\iffalse
\begin{figure*}
\begin{minipage}{0.48\textwidth}
\begin{lstlisting}
fun (@\codesimb{(y0 : list A)}@) =>(@\vspace{-0.04cm}@)
  (@\codesima{list_rect}@) _ _  (fun (@\codesima{a l IHl}@) =>(@\vspace{-0.04cm}@)
    (@\codesimc{eq_ind_r}@) _ (@\codesimd{eq_refl}@) (@\codesimc{(app_nil_r (rev l) (a::[]))}@))(@\vspace{-0.04cm}@)
    (@\codesime{eq_refl}@)(@\vspace{-0.04cm}@)
    (@\codesima{y0}@)(@\vspace{-0.04cm}@)
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\begin{lstlisting}
(@\vspace{-0.14cm}@)
- (@\codesimb{intro y0.}@)(@\vspace{-0.04cm}@)
  (@\codesima{induction y0 as [a l IHl|]}.@)(@\vspace{-0.04cm}@)
  + (@\codesimc{simpl. rewrite (app_nil_r (rev l) (a::[])).}@) (@\codesimd{auto.}@)(@\vspace{-0.04cm}@)
  + (@\codesime{auto.}@)(@\vspace{-0.04cm}@)
\end{lstlisting}
\end{minipage}
\vspace{-0.4cm}
\caption{Proof term (left) and decompiled proof script (right) for the base case of 
\lstinline{rev_app_distr} (Section~\ref{sec:overview}), with corresponding terms and tactics 
highlighted the same color.}
\label{fig:rainbow}
\end{figure*}
\fi

\mysubsubsec{Reaching Real Proof Engineers}
Many of our design decisions in implementing \toolname were informed by our partnership with
an industrial proof engineer (see Section~\ref{sec:search}).
For example, we found that the proof engineer rarely had the patience to wait more than ten seconds
for \toolname to port a function or proof.
In response, we implemented aggressive caching (with an option to disable the cache), even caching intermediate subterms that
we encounter in the course of running our proof term transformation~\circled{14}.
We also added a cache to tell \toolname not to $\delta$-reduce certain terms~\circled{14}. % caching.ml
%These caches are implemented in \href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/src/cache/caching.ml}{caching.ml}.
%or recurse into certain modules.
% set certain terms or modules as opaque to \toolname, to prevent unnecessary $\delta$-reduction.

The experiences of proof engineers also inspired new features.
For example, we implemented a special search procedure to generate custom eliminators %(\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/src/automation/search/smartelim.ml}{smartelim.ml})
to make it easier to reason about types refined by equalities like $\Sigma$\lstinline{(l : list T).length l = n}
by reasoning separately about the projections~\circled{15}. %smartelim.ml
These features along with our tactic decompiler helped with integration into proof engineering workflows.

\begin{table*}
\small
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Class} & \textbf{Config.} & \textbf{Examples} & \textbf{Repair Tools} & \textbf{Search Tools} \\
    \hline
    \multirow[t]{2}{*}{Algebraic Ornaments} & \multirow[t]{2}{*}{Auto} & List to Packed Vector, hs-to-coq \circled{3} % Example.v
    & \toolname, \textsc{Devoid}, UP & \toolname, \textsc{Devoid} \\
    & & List to Packed Vector, Standard Library \circled{16} % ListToVect.v
    & \toolname, \textsc{Devoid}, UP & \toolname, \textsc{Devoid} \\
    \hline
    Unpack Sigma Types & Auto & Vector of Particular Length, hs-to-coq \circled{3} % Example.v
    & \toolname, UP & \toolname \\
    \hline
    \multirow[t]{3}{*}{Tuples \& Records} & \multirow[t]{3}{*}{Auto} & Simple Records \circled{13} % minimal_records.v 
     & \toolname, UP & \toolname \\
    & & Parameterized Records \circled{17} % more_records.v
    & \toolname, UP & \toolname \\
    & & Industrial Use \circled{18} %(\href{https://github.com/Ptival/saw-core-coq/tree/dump-wip}{saw-core-coq})
    & \toolname, UP & \toolname \\
    \hline
    \multirow[t]{3}{*}{Permute Constructors} & \multirow[t]{3}{*}{Auto} & List, Standard Library \circled{1} % Swap.v 
    & \toolname, UP & \toolname \\
     & & Modifying a PL, \textsc{REPLica} Benchmark \circled{1} % Swap.v 
     & \toolname, UP  & \toolname \\
    & & Large Ambiguous Enum \circled{1} % Swap.v
    & \toolname, UP & \toolname \\
    \hline
    Add new Constructors & Mixed & PL Extension, \textsc{REPLica} Benchmark \circled{19} % (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/add_constr.v}{add_constr.v})
    & \toolname & \toolname (partial) \\
    \hline
    Factor out Constructors & Manual & External Example \circled{2} % (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/constr_refactor.v}{constr_refactor.v}) 
    & \toolname, UP & None \\
    \hline
    Permute Hypotheses & Manual & External Example \circled{20} %(\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/flip.v}{flip.v}) 
    & \toolname, UP & None \\
    \hline
    \multirow[t]{2}{*}{Change Inductive Structure} & \multirow[t]{2}{*}{Manual} & Unary to Binary, Classic Benchmark \circled{5} %(\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/nonorn.v}{nonorn.v})
     & \toolname, Classic & None \\
     & & Vector to Finite Set, External Example \circled{21} % (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/fin.v}{fin.v}) 
     & \toolname & None \\
    \hline
  \end{tabular}
\vspace{0.05cm}
  \caption{Some changes using \toolname (left to right): class of changes, kind of configuration, examples, and Coq tools we know of that support repair along (Repair) or automatic proof of (Search) the equivalence corresponding to each example. Tools considered are \textsc{Devoid}~\cite{Ringer2019}, the Univalent Parametricity (UP) white-box transformation~\cite{tabareau2019marriage}, and a classic tool~\cite{magaud2000changing}. \toolname is the only one with support for tactic suggestions.
We provide more nuanced comparisons to these tools and more in Section~\ref{sec:related}.}
\vspace{-0.5cm}
\label{fig:changes}
\end{table*}

\subsection{Implementing the Decompiler}
\label{sec:second}

\mysubsubsec{Induction and Rewriting}
The mini decompiler assumes more predictable versions of \lstinline{rewrite} and \lstinline{induction}
than those in Coq. \textbf{Decompile} includes additional logic to reason about these tactics~\circled{11}. % decompiler.ml
For example, Qtac assumes that there is only one \lstinline{rewrite} direction. Ltac has two rewrite directions,
and so the decompiler infers the direction from the motive.

Qtac also assumes that both tactics take the inductive motive explicitly.
In Coq, however, both tactics infer the motive automatically.
Consequentially, Coq will sometimes infer the wrong motive, % without manipulation of goals and hypotheses,
or will fail to infer a motive at all.
This is especially common for the \lstinline{rewrite} tactic, which is purely syntactic.
To handle induction, the decompiler strategically uses the \lstinline{revert} tactic to manipulate the goal
so that Coq can better infer the motive.
To handle rewrites, it uses the \lstinline{simpl} tactic to refold the goal before rewriting.
Neither of these approaches are guaranteed to work, so the proof engineer may sometimes need to tweak the output proof script appropriately.
We have found that even if we pass Coq's induction principle an explicit motive, Coq still sometimes fails due
to unrepresented assumptions.
Long term, using another tactic like \lstinline{change} or \lstinline{refine} before applying these tactics
may help with cases for which Coq cannot infer the correct motive.

\mysubsubsec{Manipulating Hypotheses}
Scaling the decompiler to Coq introduces let bindings, which are generated by 
tactics like \lstinline{rewrite in}, \lstinline{apply in}, and \lstinline{pose}.
\textbf{Decompile} implements~\circled{11} % decompiler.ml
support for \lstinline{rewrite in} and \lstinline{apply in} similarly to how it supports
\lstinline{rewrite} and \lstinline{apply}, except that it ensures that the unmanipulated hypothesis does not occur in the body of the let expression,
it swaps the direction of the rewrite, and it checks for and recurses into generated subgoals.
In all other cases, it uses \lstinline{pose}, a catch-all for let bindings.

\mysubsubsec{Pretty Printing}
After decompiling proof terms, \textbf{Decompile} pretty prints the result~\circled{11}.
Like the mini decompiler, \textbf{Decompile} represents its output language using a predefined grammar of Ltac tactics,
albeit one larger than Qtac.
It maintains the recursive proof structure and uses that for formatting. %, then uses that to print proofs of subgoals using bullet points.
%It displays the resulting proof script to the proof engineer, who can modify it as needed.
%It includes scripts that automate the process of printing all of these tactic proofs to a Coq file,
%in case the proof engineer does not want an interactive workflow.
\toolname keeps all output proof terms from the proof term transformation in the Coq environment in case the decompiler does not succeed.
Once the proof engineer has this new proof, she can remove the old version.


