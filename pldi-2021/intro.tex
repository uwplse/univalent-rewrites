\section{Introduction}

Program verification with interactive theorem provers has come a long way since its inception,
especially when it comes to the scale of programs that can be verified.
The seL4~\cite{Klein2009} verified operating system kernel, for example,
is the effort of a team of proof engineers over more than twenty years and spanning more than
a million lines of proof.
Given historical critique of verification~\cite{DeMillo1977} (emphasis ours):

\begin{quote}
A \textit{sufficiently fanatical researcher}
might be willing to devote \textit{two or 
three years} to verifying a significant 
piece of software if he could be 
assured that the software would remain stable.
\end{quote}
we can conclude that, since 1977, either verification has become much easier,
or our researchers have become much more fanatical. Unfortunately, not all has changed (emphasis still ours):

\begin{quote}
But real-life programs need to 
be maintained and modified. 
There is \textit{no reason to believe} that verifying a modified program is any 
easier than verifying the original the 
first time around.
\end{quote}
Tools that can automatically refactor or repair proofs~\cite{wibergh2019, WhitesidePhD, Dietrich2013, adams2015, Bourke12, Roe2016, robert2018, pumpkinpatch}
give us reason to believe that verifying a modified program can sometimes be easier than verifying the original the first time
around, even when proof engineers do not follow good development processes,
or when change occurs outside of proof engineers' control~\cite{PGL-045}.
Still, maintaining verified programs can be challenging: it means keeping not just the programs, but also the
specifications and proofs about those programs up-to-date.
This remains so difficult that sometimes, even experts give up in the face of change~\cite{replica}.

We make progress on two open challenges in \textit{proof repair}, the problem of automatically updating proofs in response
to changes in programs or specifications:

\begin{enumerate}
\item While there are many ways proofs need to be repaired, one need is to respond to a changed type definition.
Existing work supports very limited classes of these changes like non-structural changes~\cite{pumpkinpatch} or a predefined set
of changes~\cite{robert2018, wibergh2019}, and these are not informed by the needs of proof engineers~\cite{replica}.
\item Proof repair tools are not yet integrated with typical proof engineering workflows like tactics~\cite{PGL-045, pumpkinpatch, robert2018}.
\end{enumerate}
Our progress towards these challenges leverages three key insights:

\begin{enumerate}
\item Proof repair is a form of proof reuse---reusing proofs about one specification to derive proofs about another specification---with 
the additional challenge that one of the specifications may cease to exist.
The key to supporting proof repair is to build a proof reuse
tool that can handle that additional challenge (Section~\ref{sec:key1}). 
\item A configurable proof term transformation can be used to build such a proof repair tool,
and the result can handle many different kinds of changes (Section~\ref{sec:key2}).
\item The transformed proof terms can then be translated back to suggested tactic scripts (Section~\ref{sec:decompiler}).
\end{enumerate}

These insights informed our design of \toolname,\footnote{Name changed for double-blind.} a proof repair tool for Coq 8.8.
\toolname combines a configurable proof term transformation,
search procedures to configure the proof term transformation,
and a prototype decompiler from proof terms back to suggested tactics.
The result is a flexible proof repair tool that: 

\begin{enumerate}
\item supports changes in types informed by proof engineers and not supported by other tools, and
\item produces suggested tactic scripts as part of better workflow integration.
\end{enumerate}

\begin{figure*}
\small
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Class} & \textbf{Config.} & \textbf{Examples} & \textbf{Repair Tools} & \textbf{Search Tools} \\
    \hline
    \multirow[t]{3}{*}{Permute Constructors} & \multirow[t]{3}{*}{Auto} & List, Standard Library (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/Swap.v}{Swap.v}) & \toolname, UP & \toolname \\
     & & Modifying a PL, \textsc{REPLica} Benchmark (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/Swap.v}{Swap.v}) & \toolname, UP  & \toolname \\
    & & Large Ambiguous Enum (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/Swap.v}{Swap.v}) & \toolname, UP & \toolname \\
    \hline
    \multirow[t]{2}{*}{Algebraic Ornaments} & \multirow[t]{2}{*}{Auto} & List to Packed Vector, hs-to-coq (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/examples/Example.v}{Example.v}) & \toolname, \textsc{Devoid}, UP & \toolname, \textsc{Devoid} \\
    & & List to Packed Vector, Standard Library (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/examples/ListToVect.v}{ListToVect.v}) & \toolname, \textsc{Devoid}, UP & \toolname, \textsc{Devoid} \\
    \hline
    Unpack Sigma Types & Auto & Vector of Particular Length, hs-to-coq (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/examples/Example.v}{Example.v}) & \toolname, UP & \toolname \\
    \hline
    \multirow[t]{3}{*}{Tuples \& Records} & \multirow[t]{3}{*}{Auto} & Simple Records (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/minimal_records.v}{minimal\_records.v}) & \toolname, UP & \toolname \\
    & & Parameterized Records (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/more_records.v}{more_records.v}) & \toolname, UP & \toolname \\
    & & Industrial Use (\href{https://github.com/Ptival/saw-core-coq/tree/dump-wip}{saw-core-coq}) & \toolname, UP & \toolname \\
    \hline
    Add new Constructors & Mixed & PL Extension, \textsc{REPLica} Benchmark (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/add_constr.v}{add\_constr.v}) & \toolname & \toolname (partial) \\
    \hline
    Factor out Constructors & Manual & External Example (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/constr_refactor.v}{constr\_refactor.v}) & \toolname, UP & None \\
    \hline
    \multirow[t]{2}{*}{Change Inductive Structure} & \multirow[t]{2}{*}{Manual} & Unary to Binary, Classic Benchmark (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/nonorn.v}{nonorn.v}) & \toolname, Classic & None \\
     & & Vector to Finite Set, External Example (\href{https://github.com/uwplse/pumpkin-pi/blob/master/plugin/coq/playground/fin.v}{fin.v}) & \toolname & None \\
    \hline
  \end{tabular}
  \caption{Some changes using \toolname, from left to right: class of changes (Class), whether the class of changes uses
automatic or manual configuration (Config.), example changes in that class (Examples), and Coq tools we are aware of that can support repair along (Repair Tools) or automatic proof of (Search Tools) the equivalence correponding to each example change. The tools considered for comparison are \textsc{Devoid}~\cite{Ringer2019}, the Univalent Parametricity (UP) white-box transformation~\cite{tabareau2019marriage}, and a classic tool for changing data structures~\cite{magaud2000changing}. \toolname is the only one of these tools with support for tactic suggestions.}
\label{fig:changes}
\end{figure*} % TODO cite wb paper

Table~\ref{fig:changes} shows that \toolname can support a flexible class of changes within a unified framework.
In general, \toolname can support any change described by a deconstructed type equivalence that we call a \textit{configuration} (Section~\ref{sec:key2}).
The configuration expresses to the proof term transformation how to translate functions and proofs defined over the old version of a type
to refer only to the new version, and how to do so in a way that does not break definitional equality.
To further improve usability, \toolname contains search procedures that automatically discover configurations and prove the
equivalences they induce for certain classes of changes (\textit{automatic configuration}).
Otherwise, \toolname takes a configuration as input from the proof engineer (\textit{manual configuration}).

Our main technical advances are techniques for transforming proof terms directly to repair broken proofs in response to changes
in types, while our prototype decompiler up to tactics is important for usability in Coq.
We demonstrate flexibility and usability with four case studies (Section~\ref{sec:search}), which show that \toolname 1) can support a benchmark from a user study of Coq proof engineers, 2) can simplify dependently-typed programming, %automating manual steps from previous work,
3) can help proof engineers port functions and proofs from unary to binary numbers, and
4) has helped an industrial proof engineer at Galois integrate Coq with a company workflow and write proofs about an implementation of the TLS Handshake Protocol.
%Our experiences drive ideas (Section~\ref{sec:discussion}) that open the door to better proof engineering tools.

