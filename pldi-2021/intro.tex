\section{Introduction}

Program verification with interactive theorem provers has come a long way since its inception,
especially when it comes to the scale of programs that can be verified.
The seL4~\cite{Klein2009} verified operating system kernel, for example,
is the effort of a team of proof engineers over more than twenty years and spanning more than
a million lines of proof.
Given historical critique of verification~\cite{DeMillo1977} (emphasis ours):

\begin{quote}
A \textit{sufficiently fanatical researcher}
might be willing to devote \textit{two or 
three years} to verifying a significant 
piece of software if he could be 
assured that the software would remain stable.
\end{quote}
we could argue that, since 1977, either verification has become easier,
or researchers have become much more fanatical. Unfortunately, not all has changed (emphasis still ours):

\begin{quote}
But real-life programs need to 
be maintained and modified. 
There is \textit{no reason to believe} that verifying a modified program is any 
easier than verifying the original the 
first time around.
\end{quote}
Tools that can automatically refactor or repair proofs~\cite{wibergh2019, WhitesidePhD, Dietrich2013, adams2015, Bourke12, Roe2016, robert2018, pumpkinpatch}
give us reason to believe that verifying a modified program \textit{can} sometimes be easier than verifying the original, even when proof engineers do not follow good development processes,
or when change occurs outside of proof engineers' control~\cite{PGL-045}.
Still, maintaining verified programs can be challenging: it means keeping not just the programs, but also specifications and proofs about those programs up-to-date.
This remains so difficult that sometimes, even experts give up in the face of change~\cite{replica}.

We make progress on two open challenges in \textit{proof repair} (Section~\ref{sec:key1}), the problem of automatically updating proofs in response
to changes in programs or specifications:

\begin{enumerate}
\item While there are many ways proofs need to be repaired, one need is to respond to a changed type definition.
Existing work supports very limited classes of these changes like non-structural changes~\cite{pumpkinpatch} or a predefined set
of changes~\cite{robert2018, wibergh2019}, and these are not informed by the needs of proof engineers~\cite{replica}.
\item Proof repair tools are not yet integrated with typical proof engineering workflows like tactics~\cite{PGL-045, pumpkinpatch, robert2018},
and may impose additional proof obligations like proving relations corresponding to changes~\cite{Ringer2019}.
\end{enumerate}
%Our progress towards these challenges leverages three key insights:%
%
%\begin{enumerate}
%\item Proof repair is a form of proof reuse---reusing proofs about one specification to derive proofs about another specification---with 
%the additional challenge that one of the specifications may cease to exist.
%The key to supporting proof repair is to build a proof reuse
%tool that can handle that additional challenge (Section~\ref{sec:key1}). 
%\item A configurable proof term transformation can be used to build such a proof repair tool,
%and the result can handle many different kinds of changes (Section~\ref{sec:key2}).
%\item The transformed proof terms can then be translated back to suggested tactic scripts (Section~\ref{sec:decompiler}).
%\end{enumerate}

Our progress toward these challenges leverages a configurable proof term transformation (Section~\ref{sec:key2})
and search procedures to configure that proof term transformation, in combination with a prototype decompiler from proof terms
back to suggested tactics (Section~\ref{sec:decompiler}).
This is implemented in \toolname\footnote{Name changed for double-blind.} (Configurable Approach to Repairing \& Refactoring Outdated Tactics), a proof repair plugin for Coq 8.8.
\toolname is available on Github.\footnote{Link withheld for double-blind. See auxiliary material.}
The result is a flexible proof repair tool that: 

\begin{enumerate}
\item supports changes in types informed by proof engineers and not supported by other tools, and
\item produces suggested tactic scripts and proves relations corresponding to changes as part of better workflow integration.
\end{enumerate}

\subsection*{Addressing Challenge 1: Flexible Type Support}

The case studies in Section~\ref{sec:search}---summarized in Table~\ref{fig:changes}---show that \toolname can support a flexible class of changes informed by the needs of proof engineers within a unified framework.
In general, \toolname can support any change described by a type equivalence, though it takes the equivalence in a
deconstructed form that we call a \textit{configuration}.
The configuration expresses to the proof term transformation how to translate functions and proofs defined over the old version of a type
to refer only to the new version, and how to do so in a way that does not break definitional equality.
The proof engineer can write this configuration in Coq and feed it to \toolname (\textit{manual configuration} in Table~\ref{fig:changes}),
configuring \toolname to support the corresponding change from directly within Coq.

\subsection*{Addressing Challenge 2: Workflow Integration}

Research on workflow integration for proof repair tools is in its infancy.
\toolname is built with workflow integration in mind.
For example, \toolname is the only proof repair tool we are aware of that produces suggested tactic scripts for repaired proofs,
a challenge highlighted in existing proof repair work~\cite{pumpkinpatch, robert2018} and in 
a recent survey of proof engineering~\cite{PGL-045}.
In addition, \toolname implements search procedures that 
automatically discover configurations and prove the equivalences they induce for four different classes of 
changes (\textit{automatic configuration} in Table~\ref{fig:changes}),
decreasing the burden of proof obligations imposed on the proof engineer.
Our partnership with an industrial proof engineer has informed other changes to further improve workflow integration
(Sections~\ref{sec:implementation} and~\ref{sec:search}).

%\subsection*{Bringing it Together}

%Our main technical advances are techniques for transforming proof terms directly to repair broken proofs in response to changes
%in types, while our prototype decompiler up to tactics is important for usability in Coq.
%We elaborate on some of the examples from Table~\ref{fig:changes} to further demonstrate flexibility and usability with four case studies (Section~%\ref{sec:search}), which show that \toolname 1) can support a benchmark from a user study of Coq proof engineers, 2) can simplify dependently-typed programming, %automating manual steps from previous work,
%3) can help proof engineers port functions and proofs from unary to binary numbers, and
%4) has helped an industrial proof engineer at Galois integrate Coq with a company workflow and write proofs about an implementation of the TLS %Handshake Protocol.

